<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <script>
        /**
         * debugger
         * 写debugger的地方，在页面被打开后，相当于打了个断点
         **/
        // 我们有如下一个对象
        const obj = {
            uname: 'John',
            age: 117,
            hobbies: ['pingpong', 'soccer']
         }

         // 将obj 拷贝给 o
         const o = {}
         // 拷贝函数
         function deepCopy(newObj, oldObj){
            debugger
            // 遍历旧对象
            for(let k in oldObj){
                // 处理数组的问题，如果就对象当前属性是数组
                if(oldObj[k] instanceof Array){
                    // 则新对象当前属性也应当是数组
                    newObj[k] = []
                    // 而后递归
                    deepCopy(newObj[k], oldObj[k])
                }else{
                    // k 属性名  值就是oldObj[k]
                    newObj[k] = oldObj[k]
                }
                
            }

         }
         // 函数调用，两个参数
         deepCopy(o, obj)
         console.log(o);
         // 修改新对象也不会影响原来对象
         o.age = 20
         console.log(o);
         console.log(obj);

         /**
          * 从以上内容可以发现，与浅拷贝类似，虽然能将数组这样的对象拷贝过来，
          * 但拷贝的还是地址，如果修改新的对象，原来对象也会受影响。
          * 如下
          **/
         o.hobbies[0] = 'music'
         console.log(o);
         console.log(obj);
    </script>
</body>
</html>