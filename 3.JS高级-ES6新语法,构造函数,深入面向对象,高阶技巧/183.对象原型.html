<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <script>
        /**
         * 原型对象：指构造函数的原型，通过构造函数.prototype获取
         * 对象原型：指对象的原型，通过 对象.__proto__获取
         **/

        /**
         * 构造函数可以创建实例对象，所以实例对象可以访问构造函数的属性。
         * 构造函数同样可以创建原型对象，往原型对象上加上公共的方法。
         * 那为什么实例对象一创建好，就能用原型对象上的公共方法呢？
         * 这就要说到对象原型了。
         **/
        /**
         * 对象都会有一个属性__proto__来指向构造函数的prototype原型对象，
         * 之所以我们对象可以使用构造函数prototype原型对象的属性和方法，
         * 就是因为对象有__proto__原型的存在。
         **/

         /**
          * 注意：__proto__时JS非标准属性
          * [[prototype]]和__proto__意义相同
          * 用来表明当前实例对象指向哪个原型对象prototype
          * __proto__随想原型里面也有一个constructor属性，指向创建该实例对象的构造函数 
          **/

         function Person(name,age,gender){
            this.name = name
            this.age = age
            this.gender = gender
         }

         Person.prototype.sing = function(){console.log('唱歌');}

         // 使用构造函数来创建一个实例对象
         const John = new Person('John', 117, 'Male')
         // 来查看一下该实例对象的__proto__属性会输出什么
         console.log(John);
         console.log(John.__proto__);// 输出了一个Object对象，该对象指向了Person的原型对象prototype，其中就有sing方法和构造函数
         // 对象原型__proto__指向该构造函数原型对象prototype
         console.log(John.__proto__ === Person.prototype);
         // 对象原型中也有constructor 指向 构造函数 Person
         console.log(John.__proto__.constructor === Person);// true
    </script>
</body>
</html>